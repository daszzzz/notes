## CSS

### 垂直居中

垂直居中的话，首先需要分清楚该元素所处于的环境。

如果是在 flex 里面的话，很简单，只需要对元素设置 margin: auto 或者 align-items: center;

如果是处于表格中的话设置 vertical-align: middle; 即可垂直居中。

其他通用的情况可以将元素设置为绝对定位，然后 top 设置为 50%，然后 margin-top: 元素自身高度的一半。或者是使用 transform 将元素往上平移自身高度的 50%。如果是模态框居中的话，可以使用 vh 视口单位，然后往上移动自身高度的一半。

## javascript

### js 里面有那些基本类型

js 的基本类型分为两种，原始类型和 `object`。

原始类型有：`number` 数字，`string` 字符串，`undefined`，`null`，`symbol`, `boolean`，以及 es6 新增的符号类型 `symbol`。

### js 中什么类型是引用传递, 什么类型是值传递? 如何将值类型的变量以引用的方式传递?

对于原始类型 js 是按值传递的。对于复杂类型是按地址值复制一份，然后按地址值传递。

### 类型判断

一般可以使用 `Object.prototype.call.toString` 判断，用 `instanceof` 和 `constructor` 都存在一个问题，就是跨 iframe 的时候，由于不同宿主环境内置对象不是同一个，所以通过 `instanceof` 和 `constructor` 判断时会出错。js 是弱类型语言，大型项目里面，可以使用 flow，typescript

### 作用域

js 是词法作用域，也就是静态作用域，在函数定义时，函数会有个内部属性[[scope]]，会记录外部作用域的信息，它是一层层的，全局作用域在最底下。

当这个函数激活的时候，会创建一个执行上下文。在创建执行上下文的过程中，会创建变量对象和活动对象，和 [[scope]] 连接起来，然后就构成了一条完整的作用链。

当访问一个变量的时候，会通过这条作用域链向上查找，找到了就返回这个值，否则抛出一个错误

## 闭包（closure）

一个函数不光光只是函数，还包括它的词法环境

* 在函数定义时，函数会有个内部属性[[scope]]，会记录外部作用域的信息，它是一层层的，全局作用域在最底下。
* 当这个函数激活的时候，会创建一个执行上下文。在创建执行上下文的过程中，会通过 [[scope]] 创建一条作用链，这个作用域链又和某些属性一起，构成了当前的词法环境。函数和它保存的外部词法环境[[scope]]就是构成了闭包。函数可以通过[[scope]]访问外部环境的变量，即使它不在那个作用域之中。

## new 操作符

new 调用函数的时候，具体步骤是：

* 构建一个新的对象
* 将这个新对象的 __proto__连接到函数的prototype属性
* 函数里面的this指向这个新对象，执行这个函数
* 如果这个构造函数没有显式的返回一个对象，则返回这个新对象。

## 模块化

* 使用闭包和IIFE构建一个模块，没办法在js里引入模块
* CommonJs 规范，服务端的加载规范，同步的。
* AMD 规范，AMD 支持异步模块加载。requireJs。
* CMD 规范，按需加载，依赖可以就近写。seaJs。
* ES6 模块化，标准规定，同步和异步都兼容，但是不支持。
* systemJs 可以使用所有规范。

### this

this 是执行上下文（Execution context）的一个属性

* 在默认情况下，this会全局对象，严格模式下指向 undefined
* 在有上下文对象时，this 会指向这个对象
* 可以通过 call, apply 显式的指定 this 绑定的对象
* 通过new 操作符调用，this 会指向一个新创建的对象
* 通过箭头函数定义的函数，this 值由定义时外层的作用域来决定

### JS 原生实现深拷贝

通常情况下可以通过解析为 json 字符串实现深拷贝，es6 内部其实已经实现了深拷贝方法，叫做结构化克隆算法，这个比 json 序列化能处理更多的问题。在我们使用 history api 和 indexDB  的时候，会自动调用到这种算法。其他情况的话，我会使用一层一层解构赋值实现深拷贝。更复杂的情况就应该写特定的函数了，涉及到原型链闭包的话，不是那么容易搞的。

### 什么是原型链

* 一个对象内部有个 __proto__ 属性，指向它的原型。
* 访问一个对象的属性的时候会 __proto__ ，一级一级向上查找。没有找到则返回 undefined。
* 函数里面有个 prototype 属性，在用 new 操作符调用的时候，prototype 会被赋予给新创建的对象的 __proto__ 属性。
* es5 新增函数 Object.create 可以直接创建一条原型链。

### 

## http

### HTTP 状态码

1XX 表示接收的请求正在处理，2XX 表示请求正常处理完毕比如200成功、204成功但是没有可以返回的信息，3XX 表示重定向比如301永久性重定向，302临时重定向，304未修改，4XX 表示客户端错误，比如400 错误的请求，403 没有权限，401 未授权，404 找不到资源，5XX 服务器错误，500 服务器错误。

### get 和 post 的区别

最大的区别还是语义上的区别，get 是获取资源，post 是资源进行处理。get 在URL里，可以被缓存，可以添加历史记录，前进后退。

### 什么是 HTTPS

https 就是 http 加上加密加上认证加上完整性保护，就是https。首先会从机构申请一张证书，然后对自己的公钥进行加密发送给用户，客户端验证公钥的正确性后，会将用公钥将信息加密发送给服务器。建立连接后，会使用共享密钥加密进行通讯。

### 什么是 HTTP2

HTTP2 的核心是引入一个新的二进制分帧层。从而实现了，同一个 TCP 连接复用，给 http 请求分配优先级，压缩 http 头部，服务端推送所需的资源。

## 工程化

### 前端性能优化

前端性能主要包含两个方面：加载性能，和渲染性能。

加载性能，首先可以从减少需要加载的内容做起，不该放的可以不放，用 css3 代替图片，字体可以用点手段提取必要的字体，响应式图片，媒体查询css。

然后是减少资源的大小，可以将 HTML，CSS, JS 压缩成最小，然后开启GZIP压缩，HTTP2 压缩标头，图片可以压缩，使用 webp。

然后可以从关键渲染路径着手，优化加载顺序，第三方的js，可以 async， defer。js 放后面避免阻塞加载，css 放前面。可以使用 link preload，提升资源的优先级比如字体。一般情况下加载字体的优先级是很低的。 类似的还可以使用 preconnect 链接另外一个页面，提前处理 dns 查找和重定向的步骤。还有 prefetch，空闲时候链接。使用 HTTP2，优先加载重要资源。

缩短下载时间，可以使用 HTTP2 的服务器推送的技术。上 CDN，资源合并成一个文件，减少 http 请求，或者上 http2。

使用渐进式渲染，css，js 分模块，异步加载。使用 APP SHELL 模型，提供一个骨架页面，service worker 缓存。图片也是异步加载。异步渲染页面。

使用缓存，根据文件名的 hash 值判断过期，本地存储，indexDB，cache api。

还有渲染性能主要就是减少 js到样式渲染到布局到绘制到合成这一步骤。

## 框架

### 对比 Vue.js React 和 Angular.js

按照我目前的理解，不管是在写 React，还是 Vue.js 还是 Angular.js 也好，感觉都差不多的，我都会遵循两个思想就是数据驱动和组件化。这两种思想是跟随着 React 发展起来的。数据驱动就是我们可以通过一个 state 然后经过一系列变换得到一个 UI 界面。这个 state 是响应式的，改变 state 的时候，UI 界面也会随之改变，这就是数据驱动。组件化的话，我的理解是可以把一个组件就是一个从数据到 UI 的一个映射。数据可以从父组件接受。一个组件就是一个功能，这就有点函数式编程里面函数的味道。一系列组件放在一起经过一系列的变换就生成了完整的 UI。

React.js 和 Vue 比较的话，大体上是差不多的，都有虚拟 dom，都是组件化和响应式的。差别主要在于一些语法糖，比如 Vue.js 更推崇模版，而 React 更喜欢 jsx 的风格。性能上的话，vue 是自动追踪依赖的变化，判断是否需要渲染组件。react 可能还需要手动优化一下。Vue 还有个优势就是是渐进式的，比较轻量。

Angular.js 的话是元老了，特点是大而全，适合企业级开发。

### vue 数据绑定原理

首先会把模版代码解析为一个 token 序列。然后通过这个序列创建一个 AST 抽象语法树。然后将抽象语法树转为 vnode 树。在这个过程中，使用 with 绑定了当前的运行环境。使用 new Function 动态创建了一个渲染出vnode树的函数，最后将 vnode树 渲染成 dom 树。就完成了一个数据绑定的过程。

双向绑定的原理，主要还是依靠 ES5 object 新增的一个方法 defineProperty 实现的。vue 会遍历组件 data 下个的属性，通过 defineProperty 给他们加上 getter 和 setter。然后在组件渲染的时候，会有一个收集依赖的过程。具体是每个组件都有一个 watcher 实例，组件渲染时会触发属性的 getter，然后在 watcher 里面就会记录下这些依赖项，同时在依赖项里面也会记录上依赖它的 watcher。在设置一个属性值的时候，会调用依赖项的 setter，然后会通知 watcher。watcher 就会调用渲染函数。计算属性也是一个道理，会实例化一个 watcher。然后收集依赖，然后依赖项变化的时候，进行计算。

### 新增 vue 语法

- parse(html)，生成AST节点的时候，往节点附加信息;
- generate(ast)，生成VNode Render时候，加入代码控制运行时流程;
- render.call(vm)，生成VNode树时，提供对应的renderHelpersFunc函数，例如 _c, _v, _s 等;
- patch(vnode)，在真实的dom上处理UI渲染，事件监听等;

### vuex 

因为 vue 是数据驱动或者说是状态驱动的，通过状态映射成 ui。vuex 就是集中管理状态的一个工具。特点是单向数据流，数据只能通过提交一个 mutation 改变。好处是可以解决组件间的通信问题。大型单页面应用的话，可以便于管理数据和开发维护。

### 虚拟 DOM

首先有一个 vnode 的类，这个类里面记录着一个 node 节点，它的标签名，子节点和一些属性的信息。虚拟 DOM 就是一个 vnode 组成的树。vnode 树可以被渲染成 DOM 树。由于 dom 创建一个元素的开销比较大，所以在将老的 vnode 树替换成新的 vnode 树的过程涉及到一个 diff 的过程，只更新修改部分的 dom。

这个 diff 过程的核心在于只比较同层的节点。比较同层的一组节点过程是互相比较它们的首尾指针看是否一致，然后移动指针。如果存在key的话，就会通过key来判断是否有改变。这样效率比较高。


## 项目

### 个人介绍

你好，我叫段南天，本科毕业于合肥工业大学信息与计算科学专业。毕业后进了一家主要是做银行外包的公司，然后那家公司技术太烂了，前后端职责也分不清，找到机会我迅速就跳到了一家互联网公司。进去几个月后，前端的主管就走了，后面我基本处于单兵作战的状态。

在我在这家公司呆了半年后，维护的工作已经没有挑战性，然后我开始着手重写一套系统。技术选型方面，我考虑到当时的业界趋势，选择 angular1.x 再加上 es6 再加上 sass 作为基础的技术。当时还没有 webpack，因此我选择的是 gulp 加上 browserify 作为构建工具。这是一个完整的中后台系统，还算是比较复杂的，我是花了很多心思的，用户体验，代码方面，我都尽量的做到我当时的最好的水平。

在 16 年末的时候，这个时候 React Vue Webpack 如火如荼，改变了前端的传统开发方式。这个时候，我做的系统已经非常完善了，各个组件都已经很成熟了，开发流程也已经非常完善了，新业务开发对我来说就是随便搞搞脑子都不用带了。于是我又开始谋划着写一个桌面客户端，这个时候我采用的是 node.js + electron + vue.js + bluma + ramda + webpack 构建整个系统。这是一个个人项目，源代码 github 上都有。我其实就是当作一个网盘来开发的。功能就像一个网盘一样。

后面的话，也用 react + ant design + dva 做过独立的项目，也和同事合作开发过，重要的项目都是我都是有参与过的。但是公司业务增长的确到了一个瓶颈，我觉得我在这里的提高，也到了一个天花板，所以想要找一个更大的平台发展。

### madoka

- 构建上的话，可能就是一些压缩、合并、加 hash 的常规操作，不过还要加上处理 es6 模块化文件，处理 sass 之类的，区分测试和生产环境的差别，还是要费点功夫的。不过再我领悟到 gulp 为什么叫 gulp 后，这就不是事了。
- 结构上的话，我是用的是按业务分模块，抽出公共组件和公共方法复用。系统里面大量应用了 es6 的模版字符串，我是倾向于把 html 和 js 全都放在一起的，这样开发起来也比较方便，他们都是属于交互这一层，本来就是一体的。数据处理这一块我是抽象出来作为一个 service 的，因为很多后端传过来的数据是很原始的很脏的，在一层我会尽量把数据转化为直接能对应成视图的，数据处理这一块，是不需要交互那一层关心的。获取数据这一层我感觉我写的也比较好，我是采用函数式风格写的，将原有的 $http 函数柯里化，写成一个高阶函数。在高阶函数里面我做了一些控制，比如防重复提交，中断重复的前一个请求。这些控制都是全局的，很方便。
- 项目里，为了满足业务需要，我抽象出了很多通用的组件，比如日期选择器，下拉筛选，模态框之类的。
- 其他还有就是使用 promise 控制异步流程。活用本地存储。websocket 与后端双向通信。koa 作为前端的服务器。
- 性能优化主要还是做的是加载方面的优化，比如缓存，懒加载，调整加载顺序等。

### updrive

- 这个项目是采用 webpack 和 electron 和 vue 构建的。由于是桌面客户端所以是需要下载的。我在github里面继承了 ci 工具，当 master 变化时，会自动在第三方平台上构建好，然后发布到release里面。
- 我引入了 ramda 作为数据的基础库。就是以函数式编程的风格。css 方面，全部都是 flex 布局的，很方便也很简单。底层用了很多 nodejs 的东西，主要是文件操作方面。
- 这个系统有涉及到比较多的本地存储的东西，我采用的 indexDB，因为比较性能比较好，而且可以直接存储对象。
- 基础操作方面，我结合 windows 的资源管理器，做了优化，比如说ctrl shift 多选 全选，前进后退功能。
- 我觉得我代码写的还可以，细节上也做的还不错。github 目前也 100 多星了。后续还有很多想做的，有时间的话我都会补全的。


